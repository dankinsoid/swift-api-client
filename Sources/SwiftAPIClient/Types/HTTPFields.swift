import Foundation
#if canImport(FoundationNetworking)
import FoundationNetworking
#endif

public extension HTTPField {

	/// Returns an `Accept` header.
	///
	/// - Parameter value: The `Accept` value.
	///
	/// - Returns:         The header
	static func accept(_ value: ContentType) -> HTTPField {
        HTTPField(name: .accept, value: value.rawValue)
	}

	/// Returns a `Basic` `Authorization` header using the `username` and `password` provided.
	///
	/// - Parameters:
	///   - username: The username of the header.
	///   - password: The password of the header.
	///
	/// - Returns:    The header.
	static func authorization(username: String, password: String) -> HTTPField {
		let credential = Data("\(username):\(password)".utf8).base64EncodedString()

		return authorization("Basic \(credential)")
	}

	/// Returns a `Bearer` `Authorization` header using the `bearerToken` provided
	///
	/// - Parameter bearerToken: The bearer token.
	///
	/// - Returns:               The header.
	static func authorization(bearerToken: String) -> HTTPField {
		authorization("Bearer \(bearerToken)")
	}

	/// Returns an `Authorization` header.
	///
	/// Alamofire provides built-in methods to produce `Authorization` headers. For a Basic `Authorization` header use
	/// `HTTPField.authorization(username:password:)`. For a Bearer `Authorization` header, use
	/// `HTTPField.authorization(bearerToken:)`.
	///
	/// - Parameter value: The `Authorization` value.
	///
	/// - Returns:         The header.
	static func authorization(_ value: String) -> HTTPField {
		HTTPField(name: .authorization, value: value)
	}

	/// Returns a `Content-Disposition` header.
	///
	/// - Parameter value: The `Content-Disposition` value.
	///
	/// - Returns:         The header.
	static func contentDisposition(_ type: String, name: String, filename: String? = nil) -> HTTPField {
		let nameEncoded = name.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? name
		var value = "form-data; name=\"\(nameEncoded)\""
		if let filename {
			let filenameEncoded = filename.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? filename
			value += "; filename=\"\(filenameEncoded)\""
		}
		return HTTPField(name: .contentDisposition, value: value)
	}

	/// Returns a `Content-Encoding` header.
	///
	/// - Parameter value: The `Content-Encoding`.
	///
	/// - Returns:         The header.
	static func contentEncoding(_ value: String) -> HTTPField {
        HTTPField(name: .contentEncoding, value: value)
	}

	/// Returns a `Content-Type` header.
	///
	/// All Alamofire `ParameterEncoding`s and `ParameterEncoder`s set the `Content-Type` of the request, so it may not
	/// be necessary to manually set this value.
	///
	/// - Parameter value: The `Content-Type` value.
	///
	/// - Returns:         The header.
	static func contentType(_ value: ContentType) -> HTTPField {
		HTTPField(name: .contentType, value: value.rawValue)
	}

	/// Returns a `Sec-WebSocket-Protocol` header.
	///
	/// - Parameter value: The `Sec-WebSocket-Protocol` value.
	/// - Returns:         The header.
	static func websocketProtocol(_ value: String) -> HTTPField {
        HTTPField(name: .secWebSocketProtocol, value: value)
	}
}

// MARK: - Defaults

public extension HTTPFields {

	/// The default set of `HTTPFields` used by Alamofire. Includes `Accept-Encoding`, `Accept-Language`, and
	/// `User-Agent`.
    static let `default`: HTTPFields = HTTPFields([
        .defaultAcceptEncoding,
        .defaultAcceptLanguage,
        .defaultUserAgent
    ])
}

public extension HTTPField {

	/// Returns Alamofire's default `Accept-Encoding` header, appropriate for the encodings supported by particular OS
	/// versions.
	///
	/// See the [Accept-Encoding HTTP header documentation](https://tools.ietf.org/html/rfc7230#section-4.2.3) .
	static let defaultAcceptEncoding: HTTPField = {
		let encodings: [String]
		if #available(iOS 11.0, macOS 10.13, tvOS 11.0, watchOS 4.0, *) {
			encodings = ["br", "gzip", "deflate"]
		} else {
			encodings = ["gzip", "deflate"]
		}

		return HTTPField(name: .acceptEncoding, value: encodings.qualityEncoded())
	}()

	/// Returns Alamofire's default `Accept-Language` header, generated by querying `Locale` for the user's
	/// `preferredLanguages`.
	///
	/// See the [Accept-Language HTTP header documentation](https://tools.ietf.org/html/rfc7231#section-5.3.5).
	static let defaultAcceptLanguage = HTTPField(name: .acceptLanguage, value: Locale.preferredLanguages.prefix(6).qualityEncoded())

	/// Returns Alamofire's default `User-Agent` header.
	///
	/// See the [User-Agent header documentation](https://tools.ietf.org/html/rfc7231#section-5.5.3).
	///
	/// Example: `iOS Example/1.0 (org.alamofire.iOS-Example; build:1; iOS 13.0.0) network-client`
	static let defaultUserAgent: HTTPField = {
		let info = Bundle.main.infoDictionary
		let executable = (info?["CFBundleExecutable"] as? String) ??
			(ProcessInfo.processInfo.arguments.first?.split(separator: "/").last.map(String.init)) ??
			"Unknown"
		let bundle = info?["CFBundleIdentifier"] as? String ?? "Unknown"
		let appVersion = info?["CFBundleShortVersionString"] as? String ?? "Unknown"
		let appBuild = info?["CFBundleVersion"] as? String ?? "Unknown"

		let osNameVersion: String = {
			let version = ProcessInfo.processInfo.operatingSystemVersion
			let versionString = "\(version.majorVersion).\(version.minorVersion).\(version.patchVersion)"
			let osName: String = {
				#if os(iOS)
				#if targetEnvironment(macCatalyst)
				return "macOS(Catalyst)"
				#else
				return "iOS"
				#endif
				#elseif os(watchOS)
				return "watchOS"
				#elseif os(tvOS)
				return "tvOS"
				#elseif os(macOS)
				return "macOS"
				#elseif os(Linux)
				return "Linux"
				#elseif os(Windows)
				return "Windows"
				#elseif os(Android)
				return "Android"
				#else
				return "Unknown"
				#endif
			}()

			return "\(osName) \(versionString)"
		}()

		let userAgent = "\(executable)/\(appVersion) (\(bundle); build:\(appBuild); \(osNameVersion)) network-client"

		return HTTPField(name: .userAgent, value: userAgent)
	}()
}

extension Collection<String> {

	func qualityEncoded() -> String {
		enumerated().map { index, encoding in
			let quality = 1.0 - (Double(index) * 0.1)
			return "\(encoding);q=\(quality)"
		}.joined(separator: ", ")
	}
}
